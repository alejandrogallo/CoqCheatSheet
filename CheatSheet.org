#+INCLUDE: CheatSheet/CheatSheetSetup.org

* title                                                              :ignore:
#+TITLE: Beginning Coq Reference Sheet
# SUBTITLE: Cheat Sheet Template
# DATE: << Spring 2018 >>
# When we don't provide a date, one is provided for us.
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+DESCRIPTION: This document is written by Musa Al-hassy for his learning in the spring of 2018.
#+STARTUP: hideblocks
#+STARTUP: overview
#+TODO: { TEMPLATE(t) BEGIN-IGNORE(b) END-IGNORE(e) } | DONE(d)

* Administrivia, Syntax

+ Every Coq command ends with a period.
+ The phrase /Theorem T identifying statement S is proven by P/
  is formalised as
  #+BEGIN_SRC 
  Theorem T : S.  (* T is only a name and can be used later. *)
  Proof.
  P  (* See the current state of the proof in the CoqIde by clicking, in the toolbar, 
        on the green arrow pointing at a yellow ball;
        or do "C-c C-Enter" in Proof General with Emacs. *)
  Qed.
  #+END_SRC

+ Instead of ~Theorem~, you may also see proofs that start with
  ~Example~, ~Lemma~, ~Remark~, ~Fact~, ~Corollary~, and ~Proposition~, which all
  mean the _SAME_ thing. This difference is mostly a matter of style.

+ The command ~Admitted~, in-place of ~Qed~, can be used as a placeholder for an
    incomplete proof or definition.

    # The [Admitted] command tells Coq that we want to skip trying
    # to prove this theorem and just accept it as a given.  This can be
    # useful for developing longer proofs, since we can state subsidiary
    # lemmas that we believe will be useful for making some larger
    # argument, use [Admitted] to accept them on faith for the moment,
    # and continue working on the main argument until we are sure it
    # makes sense; then we can go back and fill in the proofs we
    # skipped.  Be careful, though: every time you say [Admitted] you
    # are leaving a door open for total nonsense to enter Coq's nice,
    # rigorous, formally checked world!

   # admit, or pretending proofs exist

    # It ends a subgoal without solving it. I use it below to let Coq's parser bypass this unproven theorem.
    # The "admit" tactic has its uses, though. When there are multiple subgoals and you want to skip over the easy ones to work on the hard one first, the "admit" tactic can be used to get the easy subgoals out of the way. Or, if you are only part way done a proof but you want send someone a Coq file that parses, "admit" can be used to fill in your blanks.
    # 
    - Useful if you have a subgoal that you want to ignore for a while.

+ ~Abort~, in-place of ~Qed~, is used to give up on a proof for the moment,
  say for presentation purposes, and it may be begun later with no error
  about theorems having the same name.

# Comment to seperate labelled enumeration above, from unlabelled below.

+ Comments :: ~(* I may be a multiline comment. *)~

+ Stand alone commands :: As top-level items, we may make commands for:
  - Normalisation :: ~Compute X~ executes all the function calls in ~X~ and prints the result.
  - Type inspection :: Command ~Check X.~ asks Coq to print the type of expression ~X~.

+ Introduce local definitions :: Two ways,
 - Simple alias: ~pose (new_thing := complicated_expression).~
 - More involved: Write tactic ~assert (x : X).~ to define a new identifier
    ~x~ for a proof of ~X~ which then follows, and is conventionally indented.

+ Imports :: Loading definitions from a library,
   #+BEGIN_EXAMPLE
Require Import Bool.
#+END_EXAMPLE

\iffalse
+ Pattern matching with ~case~ ::
   # For an element ~xs~ of a type having /n/ constructors, ~case xs~ produces ~n~ subgoals of the form ~A₁ → ⋯ → Aₙᵢ → newSubgoal~ where the ~Aⱼ~ are the arguments of the constructor.

  If we do a ~case~ on an item of type ~A \/ B~ then we obtain two new subgoals:
    ~A → …~ and ~B → …~, which may be begun with ~intros~ as usual.

  + ~case~ alters subgoals and never the context already ~intro~-duced.

The "case" tactic only changes the subgoal.
Hence whether it is invoked before all possible intros or not gives different
proof power. For example, try proving:
#+BEGIN_EXAMPLE
Theorem thm_eqb_a_t: (forall a:bool, (Is_true (eqb a true)) -> (Is_true a)).
#+END_EXAMPLE
\fi

* Pattern matching with ~destruct~

We case on value ~e~ by ~destruct e as [ a00 … am0 | ⋯ | a0n … amn ]~,
which gives us ~n~ new subgoals corresponding to the number of constructors that
could have produced ~e~ such that the /i/-th constructor has arguments ~ai0, …, akᵢ~.

+ The intros pattern ~as [ ⋯ ]~ lets us use any friendly names of our choosing.
  We may not provide it at the cost of Coq's generated names for arguments.

#  Note that the [destruct] here has no [as] clause because
#     none of the subcases of the [destruct] need to bind any variables,
#     so there is no need to specify any names.  (We could also have
#     written [as [|]], or [as []].)  In fact, we can omit the [as]
#     clause from _any_ [destruct] and Coq will fill in variable names
#     automatically.  This is generally considered bad style, since Coq
#     often makes confusing choices of names when left to its own
#     devices.

# Pattern match from the get-go

+ Many proofs pattern match on a variable right after introducing it,
  ~intros e. destruct e as [⋯]~, and this is abbreviated by the intro pattern:
  ~intros [⋯]~.

+ If there are no arguments to name, in the case of a nullary construction, we can just write ~[]~.

* Simple Tactics

+ ~exact~ :: If the subgoal matches an /exact/ hypothesis,
     Then use ~exact <hyp_name>.~

+ ~simpl~ :: 
  #  ~simpl~. It is short for ~simplify~. 
  If the current subgoal contains a function call with all its arguments, ~simpl~ will execute the function on the arguments.

  - Sometimes a call to ~unfold f~, for a particular function ~f~, is needed before ~simpl~ will work.

+ Modus ponens, or function application :: If we have ~imp : A -> B, a : A~
  then ~imp a~ is of type ~B~. This also works if the ~imp~ contains ~forall~'s.

+ Local tactic application :: ~t in s~ performs the tactic ~t~ only within
     the hypothesis, term, ~s~. For example, ~unfold defnName in item~ performs a local rewrite.   

* ~intros~ tactic: `∀, ⇒` introduction

+ To prove a statement of the form ~(forall A : Prop, Q)~ we use the ∀-introduction
  tactic, supplied with a name for the variable introduced, as in ~intros A.~

+ To prove an implication ~A ⇒ B~ we again use, say, ~intros pf_of_A.~
  # since implications are implicitly universally quantified:
  # $A ⇒ B$ denotes $(forall pf_of_A : B, C)$.

+ The ~intros~ command can take any positive number of
  arguments, each argument stripping a ~forall,~ (or ~->~), off the front of
  the current subgoal.
  # We can combined all
  # the ~intros~ into a single command, but it is cleaner to
  # introduce the Props and the derived values separately.
* ~Notation~, ~Definition~, and the tactics ~fold~ and ~unfold~

~Definition~ is a vernacular command that says two expressions are interchangeable. 
Below ~(not A)~ and ~A -> False~ are declared interchangeable.

#+BEGIN_EXAMPLE 
Definition not (A:Prop) := A -> False.

Notation "~ x" := (not x) : type_scope.
#+END_EXAMPLE

Tactics ~unfold defnName~ and ~fold defnName~ will interchange them. 

~Notation~ creates an operator and defines it as an alternate notation for an expression.

( Use ~intros~ when working with negations since they are implications! )

# (The ~Notation~ command is how the operator ~->~ was created from ~(forall ...)~.)

**fix me**
#+BEGIN_EXAMPLE coq
(* If this is a recursive function, use `Fixpoint` in-place of `Definition`.*)
Definition my_function (a₀ : A₀) ⋯ (aₙ : Aₙ) : B :=
  match a₀ , …,  aₙ with
  | C₀ p₀ … pₘ , …, Cₙ q₀ ⋯ qₖ =>  definition_here_for_these_constructors_Cᵢ
  ⋮
  end.
#+END_EXAMPLE

+ Telescoping :: If ~x₀, ⋯, xₙ~ have the same type, say ~T~,
		 we may declare their typing by ~(x₀ ⋯ xₙ : T)~.
+ Notation :: Before the final ".", we may include a variant of
   ~where "n + m" := (my_function n m) : B_scope.~ for introducing
   an operator immediately with a function definition.

* COMMENT Proof Refinement

Suppose our goal is to prove B but we have a proof ~imp : A → B~,
then if we have an ~A~ function application suffices. However,
when we have no ~A~ lying about and would like to focus on constructing
such an ~A~ we use ~refine (imp _)~ which forces us into constructing
a subgoal ~A~. It is good practice to then indent proof for the new subgoal.

+ If ~imp~ has more arguments then ~refine~ would take more underscores corresponding
  to the arguments we do not have proofs of; we may place the arguments which we
  do have access to there and then.

+ Needless to say, a ~refine~ may occur within a ~refine~.

\iffalse
#+BEGIN_SRC 
Theorem nexted_refine_example : (forall A B C : Prop, A -> (A->B) -> (A->B->C) -> C).
Proof.
  intros A B C.
  intros Apf AtoB AthenBthenC.
  refine (AthenBthenC _ _).
    exact Apf.
    refine (AtoB _).
      exact Apf.
Qed.

Theorem direct_proof : (forall A B C : Prop, A -> (A->B) -> (A->B->C) -> C).
Proof.
  intros A B C Apf AB ABC.
  exact (ABC Apf (AB Apf)).
Qed.
#+END_SRC
\fi


* newpage :ignore:

\newpage

* Examples of Common Datatypes

+ ~Prop~ Type
  - A ~Prop~ either has a proof or it does not have a proof. 
  - Coq restricts Prop to being either proven or unproven, rather than true or false.   

+ Sums
   #+BEGIN_EXAMPLE
Inductive or (A B:Prop) : Prop :=
  | or_introl : A -> A \/ B
  | or_intror : B -> A \/ B
where "A \/ B" := (or A B) : type_scope.
#+END_EXAMPLE

+ Products
  #+BEGIN_EXAMPLE
Inductive and (A B:Prop) : Prop :=
  conj : A -> B -> A /\ B
where "A /\ B" := (and A B) : type_scope.
#+END_EXAMPLE

+ ℕaturals
  #+BEGIN_EXAMPLE
Inductive nat : Set :=
  | O : nat   (* Capital-letter O, not the number zero. *)
  | S : nat -> nat.
#+END_EXAMPLE

+ Options
  #+BEGIN_EXAMPLE 
Inductive option (A : Type) : Type :=
  | Some : A -> option A
  | None : option .A
#+END_EXAMPLE

+ Lists
  #+BEGIN_EXAMPLE
Inductive list (A : Type) : Type :=
 | nil : list A
 | cons : A -> list A -> list A.

Infix "::" := cons (at level 60, right associativity) : list_scope.
#+END_EXAMPLE

* ~True, False, true, false~

The vernacular command ~Inductive~ lets you create a new type.

+ The empty Prop, having no proofs, is ~False.~
+ The top Prop, having a single proof named ~I~, is ~True~.
+ The ~bool~ type has two values: ~true~ and ~false~.

#+BEGIN_EXAMPLE
Inductive False : Prop := .

Inductive True : Prop :=
  | I : True.

Inductive bool : Set :=
  | true : bool
  | false : bool.
#+END_EXAMPLE

\iffalse principle of explosion
#+BEGIN_EXAMPLE
Theorem ex_falso_quod_libet : (forall A : Prop, False -> A).
Proof.
  intros A []
Qed.
#+END_EXAMPLE
# Instead of "exact", we use the "case" tactic. "case" is powerful: it creates subgoals for every possible construction of its argument. Since there is no way to construct a False, "case" creates no subgoals! Without a subgoal, we're done!
\fi

In the boolean library there is a function ~Is_true~ which converts booleans
into their associated Prop counterparts.
* Existence ∃

# The mathematical /∃ x : X • P x/ is captured by ~ex P~ for ~P : X -> Prop~.
#+BEGIN_EXAMPLE
Inductive ex (A:Type) (P:A -> Prop) : Prop :=
  ex_intro : forall x:A, P x -> ex (A:=A) P.

Notation "'exists' x .. y , p" := (ex (fun x => .. (ex (fun y => p)) ..))
  (at level 200, x binder, right associativity,
   format "'[' 'exists'  '/  ' x  ..  y ,  '/  ' p ']'")
  : type_scope.
#+END_EXAMPLE

Note that the constructor takes 3 arguments: The predicate ~P~, the witness ~x~, and a proof of ~P x~.

If we pose a witness beforehand then ~refine (ex_intro _ witness _).~, Coq will infer ~P~ from
the current goal and the new subgoal is the proof that the witness satisfies the predicate.

\iffalse
Note that De Morgan's law, ¬∀≈∃¬, holds! Prove an implication to see this.
#+BEGIN_EXAMPLE
Theorem demorgan : (forall P : Set->Prop, (forall x, ~(P x)) -> ~(exists x, P x)).
Proof.
  intros P.
  intros noP.
  unfold not.
  intros ex.
  destruct ex as [ witness  proof ].
  pose (uhoh := noP witness).
  pose (absurd := uhoh proof).
  case absurd.
Qed.
#+END_EXAMPLE
The converse is also true!
\fi



* Equality, ~rewrite~, and ~reflexivity~

Two operators,
+ ~x = y :> A~ says that ~x~ and ~y~ are equal and both have type ~A~. 
+ ~x = y~ does the same but let's Coq infer the type ~A~.

#+BEGIN_EXAMPLE
Inductive eq (A:Type) (x:A) : A -> Prop :=
    eq_refl : x = x :>A

where "x = y :> A" := (@eq A x y) : type_scope.

Notation "x = y" := (x = y :>_) : type_scope.
#+END_EXAMPLE

\iffalse

The "Inductive" statement creates a new type "eq" which is a function of a type A and 2 values of type A to Prop. (NOTE: One value of type A is written (x:A) before the ":" and the other is written "A ->" after. This is done so Coq infers the type "A" from the first value and not the second.) Calling "eq" with all its arguments returns a proposition (with type Prop). A proof of "eq x y" means that "x" and "y" both have the same type and that "x" equals "y".

The only way to create a proof of type "eq" is to use the only constructor "eq_refl". It takes a value of "x" of type "A" and returns "@eq A x x", that is, that "x" is equal to itself. (The "@" prevents Coq from inferring values, like the type "A".) The name "eq_refl" comes from the reflexive property of equality.

\fi

Rather than using ~destruct~, most proofs using equality use the tactics ~rewrite ⟨orientation⟩.~ 
If ~xEy~ has type ~x = y~, then ~rewrite -> xEy~ will replace ~x~ with ~y~ in the subgoal, while using orientation ~<-~ rewrites the
other-way, replacing ~y~ with ~x~.
  #
  # Note the space with "rewrite" and "<-".

 - This can also be used with a previously proved theorem.
   If the statement of said theorem involves quantified variables,
   Coq tries to instantiate them by matching with the current goal.

 - As with destructing, the pattern ~intros eq. rewrite -> eq.~
   is abbreviated by the intro pattern ~intros [].~ which performs
   a left-to-right rewrite in the goal.

** reflexivity tactic :ignore:

Use the ~reflexivity~ tactic to discharge a goal of type ~x = x~.
 + This tactic performs some simplification automatically
   when checking that two sides are equal; e.g., it tries ~simpl~ and ~unfold~.

    \iffalse
    Moreover, it will be useful later to know that [reflexivity]
    does somewhat _more_ simplification than [simpl] does -- for
    example, it tries "unfolding" defined terms, replacing them with
    their right-hand sides.  The reason for this difference is that,
    if reflexivity succeeds, the whole goal is finished and we don't
    need to look at whatever expanded expressions [reflexivity] has
    created by all this simplification and unfolding; by contrast,
    [simpl] is used in situations where we may have to read and
    understand the new goal that it creates, so we would not want it
    blindly expanding definitions and leaving the goal in a messy
    state.
    \fi

* Discrepancy

Coq uses the operator ~<>~ for inequality, which really means /equality is unprovable/ or /equality implies False/.
#+BEGIN_EXAMPLE coq
Notation "x <> y  :> T" := (~ x = y :>T) : type_scope.
Notation "x <> y" := (x <> y :>_) : type_scope.
#+END_EXAMPLE

** discriminate                                                      :ignore:

Datatype constructors are necessarily disjoint, hence if we ever obtain a proof ~pf~
of distinct constructors being equal then we may invoke ~discriminate pf~ to short-circuit the
current goal, thereby eliminating a case that could not have happened.

\iffalse
~discriminate~ operates on a hypothesis where values of inductive type are compared using equality. If the constructors used to generate the equality type are different, like here where we have ~true = false~, then Coq knows that situation can never happen. It's like a proof of ~False~. In that case, ~discriminate <hypname>.~ ends the subgoal.

#+BEGIN_EXAMPLE
Theorem example  : forall A, true = false -> A.
Proof.
  intros A tEf.
  discriminate tEf.
Qed.
#+END_EXAMPLE

When working with inductive types, you will use "discriminate" to eliminate a lot of cases that can never happen.

RULE: If you have a hypothesis "<name> : (<constructor1> ...) = (<constructor2> ...) OR "<name> : <constant1> = <constant2> Then use the tactic "discriminate <name>"
\fi


* COMMENT More Basic Tactics

+ If we have access to some ~H : ∀ 𝓍, A₁ → … Aₙ → G~ where ~G~, 
  up to substitution, is exactly
  the current goal, then ~apply f~ introduces ~n~ many new subgoals
  that need to then be tackled and variables ~𝓍~ are inferred.
  ( "Modus Ponens"! )

  - When a variable cannot be inferred we must give it explicitly: ~apply H with (xᵢ := ⋯).~
  - ~apply~ will perform simplification first, if needed.

+ ~symmetry~ switches the left and right sides of an equality in
    the goal.

+ The constructors of inductively defined types are injective and disjoint.
  These principles are invoked by the tactic ~inversion H~, where ~H~ denotes an
  equality involving constructors as main application.
  For same constructors this acts as injectivity, generating all equations 
  resulting from ~H~ and rewriting the goal along them. 
  For distinct constructors, it produces no goals: What you have is impossible,
  ergo a contradiction whence anything follows.
 
   - We can name the equations that ~inversion~ generates with an
    ~as ...~.

+ This is useful theorem, not a tactic:
  ~f_equal : ∀ (A B : Type) (f: A -> B) (x y: A), x = y -> f x = f y~

+ Using Tactics on Hypotheses:
  By default, most tactics work on the goal and leave the context unchanged.
  However, most tactics also have a variant that performs a similar operation
  on a statement in the context: ~t in H~ performs tactic ~t~ only on ~H~ thereby
  altering only ~H~.

*With induction, don't introduce things unless you have to!*
What we can do instead is to first introduce all the quantified
    variables and then _re-generalize_ one or more of them,
    selectively taking variables out of the context and putting them
    back at the beginning of the goal.  The [generalize dependent m]
    tactic does this.

* COMMENT WOAH :: new stuff follows

\columnbreak

* COMMENT footer

Here is a tiny tweak for org-mode. If you add the following option to your emacs config file

(setq org-highlight-latex-and-related '(latex))

Then inline latex like $y=mx+c$ will appear in a different colour in an org-mode file to help it stand out.
( See below! )

eval: (setq NAME (buffer-name))
compile-command: (progn (org-latex-export-to-pdf) (eshell-command (concat "evince " NAME ".pdf &")))

# Local Variables:
# eval: (setq NAME (file-name-sans-extension buffer-file-name))
# eval: (setq org-highlight-latex-and-related '(latex))
# eval: (visual-line-mode t)
# eval: (require 'ox-extra)
# eval: (ox-extras-activate '(ignore-headlines))
# eval: (make-variable-buffer-local 'org-structure-template-alist)
# eval: (setq PARALLEL (concat "# \n#+begin_parallel latex \n?\n#+end_parallel"))
# eval: (add-to-list 'org-structure-template-alist `("p" ,PARALLEL))
# eval: (setq TEMPLATE (concat "#+NAME: ?\n#+BEGIN_SRC c :tangle sheet_code.c\n?\n#+END_SRC"))
# eval: (add-to-list 'org-structure-template-alist `("s" ,TEMPLATE))
# compile-command: (progn (org-latex-export-to-pdf) (eshell-command (concat "evince " (file-name-sans-extension buffer-file-name) ".pdf &")))
# org-latex-inputenc-alist: (("utf8" . "utf8x"))
# eval: (setq org-latex-default-packages-alist (cons '("mathletters" "ucs" nil) org-latex-default-packages-alist))
# End:
