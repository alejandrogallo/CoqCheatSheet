#+INCLUDE: CheatSheetSetup.org

* title                                                              :ignore:
#+TITLE: Reference Sheet for ``What I'm Currently Learning''
# SUBTITLE: Cheat Sheet Template
# DATE: << Spring 2018 >>
# When we don't provide a date, one is provided for us.
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+DESCRIPTION: This document is written by Musa Al-hassy for his learning in the spring of 2018.
#+STARTUP: hideblocks
#+STARTUP: overview
#+TODO: { TEMPLATE(t) BEGIN-IGNORE(b) END-IGNORE(e) } | DONE(d)


* Hello, World!

+ Pretty PDF :: Enter ~M-x compile~ to produce a nice looking PDF of your reference sheet.
  - I've bound this command to ~C-c C-m~ in my Emacs setup ;-)

+ Section Headers :: A usual Org header, say ~* my section~, results in the boxed headers
     used in this cheat sheet.

+ Parallel Environments :: The sequence ~<p TAB~ produces a `parallel' environment for
     producing text side-by-side. The column break is automatic, but as 
     this is sugar for a ~minipage~ containing a ~multicolum~ we can force a column
     separation with ~\columnbreak~: This command, in Org, necessities newlines between
     the items being separated.

\vspace{1em}
To learn more, manipulating this source is the way to go!

\newpage

* Org-mode Basics

Read [[https://orgmode.org/worg/org-tutorials/org4beginners.html][Org-mode for beginners]] for a refresher!
  - For more see [[https://orgmode.org/orgguide.pdf][The Compact Org-mode Guide]].

\vspace{1em}

+ Reloading :: To reload a file with updated org settings, press
 ~C-c C-c~ on a settings line --i.e., one beginning with a ~#+~, to reset the 
  temporary file cache.

+ Inclusion :: During export, you can include the content of another file. 
  - Syntax: ~#+INCLUDE: "‚ü®fileName‚ü©" [‚ü®markup‚ü© [‚ü®language‚ü©]]~
    * ~markup ::= src | example~
    * ~language ::= C | haskell | emacs-lisp | ‚ãØ~ 
    * If the markup is not given, the text will be assumed to be in 
      Org mode format and will be processed normally; c.f., [[https://orgmode.org/manual/In_002dbuffer-settings.html][Setup files]].
  
  - To visit the file, ~C-c '~ while the cursor is on the line with the file name.

* Grep

+ Find all files containing specific text :: \forcenewline
  `r'ecursively look for the `w'hole given pattern: \\
  ~grep -rw '/path/to/somewhere/' -e 'pattern'~

  # - Example: Look for a word starting at the root, ~grep -rw '/' -e 'lattice'~

+ Better :: ~ack 'text-to-find-here' locationToBeginLooking~
  - [[https://beyondgrep.com/][ack]] is like grep, but for source code.
  - It looks prettier and more informative. 	    


* space, newpage :ignore:

\vspace{15em} 

\centerline{The next page contains sample output from a logic-based class.}
\newpage

* Latex setup to make example sections work :ignore:

#+BEGIN_EXPORT latex

% from Wolfram Kahl's CalcStyleV9
\def\withrule{\vrule height1.57ex depth0.43ex width0.12em}
\def\with{\kern0.7em \withrule \kern0.7em }

\def\even{ \mathsf{even} \, }
\def\eq{ \;=\; }
\def\lorS{ \quad\lor\quad }
\def\lors{ \;\lor\; }
\def\landS{ \quad\land\quad }
\def\lands{ \;\land\;}

\def\equivS{ \quad\equiv\quad }
\def\equivs{ \;\equiv\;}

\def\eqS{ \quad=\quad }
\def\eqs{ \;=\;}

\def\subseteqs{ \;\subseteq\; }
\def\subseteqS{ \quad\subseteq\quad }

\def\impliesS{ \quad\Rightarrow\quad }
\def\impliess{ \;\Rightarrow\;}
\def\implies{ \Rightarrow }

\def\spot{ \;\bullet\; }

\def\meet{ \;\sqcap\; }
\def\join{ \;\sqcup\; }
\def\sqleq{ \sqsubseteq }
\def\sqleqs{ \;\sqsubseteq\; }

\def\Id{\mathsf{Id}}
\def\true{\mathsf{true}}
\def\false{\mathsf{false}}
\def\fst{\mathsf{fst}}
\def\snd{\mathsf{snd}}

\def\IF #1 : #2 : #3 \FI{ \mathsf{if}\; { #1 } \;\mathsf{then}\; { #2 } \;\mathsf{else}\; { #3 } \;\mathsf{fi} }

\def\RR{\mathbb{R}}
\def\NN{\mathbb{N}}
\def\ZZ{\mathbb{Z}}
\def\22{\mathbf{2}}
\def\11{\mathbf{1}}

\def\notOccurs#1#2{ $\lnot \occurs{#1}{#2}$}
#+END_EXPORT

* Propositional Calculus

+ Metatheorem :: Any two theorems are equivalent; ` $\true$ ' is a theorem.

[[https://ac.els-cdn.com/S0020019000002052/1-s2.0-S0020019000002052-main.pdf?_tid=35e86bb2-edb0-11e7-b1fe-00000aab0f26&acdnat=1514672861_56b3d86466d284cbc76cc2641c47af86][_Equivales_]] is an equivalence relation that is associative --- $((p \equiv q) \equiv r)\equivs(p \equiv (q \equiv r))$ ---
and has identity $\true$.

\underline{Discrepancy} ` $\not\equiv$ ' is symmetric, associative, has identity ` $\false$ ',
mutually associates with equivales --- $((p \not\equiv q) \equiv r) \equivs (p \not\equiv (q \equiv r))$ ---
and mutually interchanges with it as well
--- $p \not\equiv q \equiv r \equivs    p \equiv q \not\equiv r$ ---.

*** implication :ignore:

\vspace{1ex}

\underline{Implication} has the alternative definition $p \implies q \;\equiv\; \lnot p \lor q$,
has $\true$ as left identity and $\false$ as right zero,
distributes over $\equiv$ in the second argument, and is self-distributive;
and has the properties

# 
#+begin_parallelNB
+ Shunting ::  \invisible{hi}\vspace{-0.5em}
  |$ p \land q \implies r \equivS  p \implies (q \implies r)$|

+ Contrapositive ::  \invisible{hi}\vspace{-0.5em}
  | $ p \implies q \quad\equiv\quad \lnot q \implies \lnot p$ |

\columnbreak

+ Modus Ponens :: \invisible{hi}\vspace{-2em}		  
  | $p \land (p \implies q)$ | \equiv   | $p \land q$ |
  | $p \land (q \implies p)$ | \equiv   | $p$         |
  | $p \land (p \implies q)$ | \implies | $q$         |

#+end_parallelNB

Moreover it has the useful property ``(3.62)'': 
 $p \implies (q \equiv r) \equivS p \land q    \equivs    p \land r$.

*** conjunction and disjunction                                      :ignore:
\vspace{1ex}
\underline{Conjunction and disjunction} distribute over one another,
$\lor$ distributes over $\equiv$,
$\land$ distributes over $\equiv-\equiv$
in that $p \land (q \equiv r \equiv s) \equivS p \land q \equivs p \land r  \equivs p \land s$,
and they satisfy,

| *Excluded Middle* | *Contradiction*                 | *Absorption*                                | *De Morgan*                                      |
| $p \lor \lnot p$  | $p \land \lnot p \equiv~\false$ | $p \land (\lnot p \lor q) \equiv p \land q$ | $\lnot (p \land q) \equiv \lnot p \lor  \lnot q$ |
|                   |                                 | $p \lor (\lnot p \land q) \equiv p \lor  q$ | $\lnot (p \lor q)  \equiv \lnot p \land \lnot q$ |


**** COMMENT alternate table 
#+begin_parallel3NB

+ Excluded Middle ::  $p \lor \lnot p$

+ Contradiction ::
  #+LaTeX: {hi. \vspace{-2em} $\invisible{Hi! Hello!}~p \land \lnot p \equiv~\false$}
  
  # + \scriptsize Contradiction :: \scriptsize $p \land \lnot p \equiv~\false$
  
\columnbreak
  
+ Absorption :: 
    | $p \land (\lnot p \lor q)$ | \equiv | $p \land q$ |
    | $p \lor (\lnot p \land q)$ | \equiv | $p \lor  q$ |

\columnbreak

+ De Morgan ::
   | $\lnot (p \land q)$ | \equiv | $\lnot p \lor  \lnot q$ |
   | $\lnot (p \lor q)$  | \equiv | $\lnot p \land \lnot q$ |

#+end_parallel3NB

* [[https://frama-c.com/][Loops implement finite quantifications]]

#+LATEX_HEADER: \DeclareUnicodeCharacter{119931}{\ensuremath{\mathbf{T}}} % math bold caps ùëª

A finite quantification can be defined axiomatically
by the empty-range rule and split-off term rules.
Together these form a recursive definition which can be phrased as a loop.
#
#+begin_parallel c

#+NAME: ?
#+BEGIN_SRC c :tangle sheet_code.c
// For -‚äï- : ùëª ‚Üí ùëª ‚Üí ùëª,
// fold(A,a,b) ‚âà (‚äï x : a..b-1 ‚Ä¢ A[x]) 
/*@ axiomatic Fold { 
  @   
  @ logic ùëª
  @   fold{L}(ùëª *A, integer a, integer b)
  @   reads a,b,A, A[..] ;
  @
  @ axiom foldEmptyRange{L} :
  @   \forall ùëª *A, integer a, b; a >= b
  @   ==>  fold(A,a,b) == identity(‚äï);
  @
  @ axiom foldSplitOffTerm{L} :
  @   \forall ùëª *A, integer a, b; a <= b
  @   ==>     fold(A, a, b+1) 
  @        == fold(A, a, b  ) ‚äï A[b];
  @ }
  @*/
#+END_SRC

\columnbreak

#+NAME: ?
#+BEGIN_SRC c :tangle sheet_code.c
/*@ requires \valid(A+(0..N-1));
  @ assigns \nothing;
  @ ensures \result == fold(A,0,N);
  @*/
ùëª fold(int N, ùëª* A) {

    ùëª total = identity(‚äï);
    
    /*@ loop invariant 0 <= n <= N;
      @ loop invariant total == fold(A,0,n);
      @ loop assigns n, total;
      @ loop variant N-n;
    */
    for(int n = 0; n != N; n++)
        total = total ‚äï A[n];
    return total;
}
#+END_SRC
#+end_parallel

This pseudo-code is reified by giving concrete values
for ~(ùëª, ‚äï, identity)~ such as ~(int, +, 0)~ or ~(bool, ||, false)~.
Any [[https://en.wikipedia.org/wiki/Monoid][monoid]] will do.


\newpage

* Lattices
# Environments
# Our common environments will be the following distributive lattices
The distributive lattice interface /(L, ‚äë, ‚äì, ‚äî, ‚ä•, ‚ä§)/ has the following implementations:

+ Booleans: $(ùîπ, \implies, \land, \lor, \false, \true)$ 
  #+LaTeX: {\hfill\color{red}---Our ambient logic!}
  # Assume this sheet instantiated to this structure.

+ Extended Number Line:  $(\RR, \leq, \min, \max, -\infty, +\infty)$ 

+ Naturals under division: $(\NN, \, |, \gcd, \mathsf{lcm}, 1, 0)$

  # \item Sets : $(\power \ X, \subseteq, \cap, \cup, \emptyset, X)$
+ Substructures of a given /datatype/ with the substructure ordering.
   \newline E.g., sets, lists, and graphs with subset, subsequence, and subgraph ordering.
   # %, respectively.
   # Subllists/subtrees/subgraphs/$\cdots$ of a given one with subsequence/subtree/subgraph ordering.

# \item Programs ordered by refinement with join being demonic choice % $\framebox(3,10){}$
#   having bottom element be the \verb+ABORT+ program.

An /order/ is a relation /-‚äë- : L ‚Üí L ‚Üí ùîπ/  satisfying the following three properties:
| *Reflexivity* | *Transitivity*              | *Antisymmetry*            |
| /a ‚äë a/     | /a ‚äë b ‚àß b ‚äë c ‚áí a ‚äë c/ | /a ‚äë b ‚àß b ‚äë a ‚áí a = b/ |

An order is /bounded/ if there are elements /‚ä§, ‚ä• : L/ being the lower and upper bounds of all other elements:
| *Top Element*    | *Bottom Element* |
| $a \sqleqs \top$ | $\bot \sqleqs a$ |

A /lattice/ is a pair of operations /-‚äì-, -‚äî- : L ‚Üí L ‚Üí L/ specified by the properties:
| *‚äî-Characterisation*          | @@latex: $\qquad$@@ | *‚äì-Characterisation*                        |
| @@latex: $a ‚äë c ‚àß b ‚äë c \equivS a ‚äî b ‚äë c$ @@ | | @@latex: $c ‚äë a ‚àß c ‚äë b \equivS c ‚äë a ‚äì b$ @@ |
# \hfill{\color{grey}(8.6)}}

Let $\square$ be one of $\meet$ or $\join$, then:
| *Symmetry of ‚ñ°* | *Associativity of ‚ñ°* | *Idempotency of ‚ñ°* |
| $a ‚ñ° b \eqs b ‚ñ° a$ | $(a ‚ñ° b) ‚ñ° c \eqs a ‚ñ° (b ‚ñ° c)$ | $a ‚ñ° a \eqs a$     |


| *Zero of ‚ñ°*    | *Identity of ‚ñ°* | *Absorption*      | *Self-Distributivity of ‚ñ°* |
|  $a ‚äî ‚ä§ = ‚ä§$    | $a ‚äî ‚ä• = a$    |  $a ‚äì (a ‚äî b) = a$ | $a ‚ñ° (b ‚ñ° c) \eqS (a ‚ñ° b) ‚ñ° (a ‚ñ° c)$ |
|  $a ‚äì ‚ä• = ‚ä•$  | $a ‚äì ‚ä§ = a$      | $a ‚äî (a ‚äì b) = a$ | |


| *Weakening / Strengthening* | *Induced Defs. of Inclusion* | *Golden Rule*                                    |
| $a \;‚äë\; a ‚äî b$             | $a ‚äë b \equivS a ‚äî b \eqs b$ | $a ‚äì b \;=\; a \hspace{1.52em}\equivs b = a ‚äî b$ |
| $a ‚äì b \;‚äë\; a$             | $a ‚äë b \equivS a ‚äì b \eqs a$ | $a ‚äì b \;=\; a ‚äî b \equivs a = b$                |
| $a ‚äì b \;‚äë\; a ‚äî b$         |                              | $a ‚äî b \;‚äë\; a ‚äì b \equivs a = b$                |
| $a ‚äî (b ‚äì c) \;‚äë\; a ‚äî b$ | *Monotonicity of ‚ñ°*         |                                                  |
| $a ‚äì b \;‚äë\; a ‚äì (b ‚äî c)$ | $a ‚äë b \lands c ‚äë d \impliess a ‚ñ° c \;‚äë\; b ‚ñ° d$ |                             |

# \hfill{\color{grey}(7.9)

#+BEGIN_EXPORT latex
{\small \textbf{Duality Principle:} \\
If a statement $S$ is a theorem, then so is
$S[(\sqleq, \meet, \join, \top, \bot) := (‚äí, \join, \meet, \bot, \top)]$}.
#+END_EXPORT



* COMMENT footer

Here is a tiny tweak for org-mode. If you add the following option to your emacs config file

(setq org-highlight-latex-and-related '(latex))

Then inline latex like $y=mx+c$ will appear in a different colour in an org-mode file to help it stand out.
( See below! )

eval: (setq NAME (buffer-name))
compile-command: (progn (org-latex-export-to-pdf) (eshell-command (concat "evince " NAME ".pdf &")))

# Local Variables:
# eval: (setq NAME (file-name-sans-extension buffer-file-name))
# eval: (setq org-highlight-latex-and-related '(latex))
# eval: (visual-line-mode t)
# eval: (require 'ox-extra)
# eval: (ox-extras-activate '(ignore-headlines))
# eval: (make-variable-buffer-local 'org-structure-template-alist)
# eval: (setq PARALLEL (concat "# \n#+begin_parallel latex \n?\n#+end_parallel"))
# eval: (add-to-list 'org-structure-template-alist `("p" ,PARALLEL))
# eval: (setq TEMPLATE (concat "#+NAME: ?\n#+BEGIN_SRC c :tangle sheet_code.c\n?\n#+END_SRC"))
# eval: (add-to-list 'org-structure-template-alist `("s" ,TEMPLATE))
# compile-command: (progn (org-latex-export-to-pdf) (eshell-command (concat "evince " (file-name-sans-extension buffer-file-name) ".pdf &")))
# org-latex-inputenc-alist: (("utf8" . "utf8x"))
# eval: (setq org-latex-default-packages-alist (cons '("mathletters" "ucs" nil) org-latex-default-packages-alist))
# End:
